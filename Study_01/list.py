# ✅ 여러 개의 데이터를 한꺼번에 관리하는 방법
# - 프로그램에서는 여러 개의 데이터를 저장하고 관리해야 하는 경우가 많다.
# - 예를 들어, 한 반의 학생 30명의 수학 점수를 저장한다고 가정해보자.

# ❌ 기존 방식 (개별 변수를 사용)
# - 1번 학생의 점수를 student1, 2번 학생을 student2, ..., 30번 학생을 student30에 저장한다고 하면
#   변수가 너무 많아지고, 관리가 어려워진다.

# ✅ 기존 방식의 문제점:
# 1️⃣ 변수가 30개나 되어서 관리가 어려움.
# 2️⃣ 변수 이름이 서로 비슷해서 헷갈림.
# 3️⃣ 전체 평균을 구하거나, 순서를 정렬하려면 모든 변수를 하나씩 불러와야 함.
# 4️⃣ 새로운 학생이 추가되거나 삭제될 경우 변수를 새로 만들거나 수정해야 하는 번거로움이 있음.

# ✅ 해결 방법: 데이터를 한꺼번에 모아서 관리하기
# - 여러 개의 데이터를 **하나의 묶음으로 저장**하면 보다 효율적으로 관리할 수 있음.
# - 한 번에 여러 개의 데이터를 저장할 수 있는 방법을 사용하면 평균을 계산하거나 정렬하는 작업도 쉬워짐.

# ✅ 데이터 묶음의 장점:
# 1️⃣ 데이터를 하나의 변수로 일괄 관리할 수 있음.
# 2️⃣ 개별 데이터를 쉽게 접근하고 활용 가능.
# 3️⃣ 추가, 삭제, 정렬 등 다양한 작업을 보다 간편하게 수행 가능.

# ✅ 앞으로 배울 내용:
# - 여러 개의 데이터를 한 번에 저장하고 관리하는 방법
# - 데이터를 보다 효율적으로 활용하는 방법

# 리스트 여러 개의 사탕을 하나의 변수에 저장하는 코드
candies = ['딸기맛', '레몬맛', '수박맛', '박하맛', '우유맛']
print(candies)

# ✅ 리스트(List)란?
# - 여러 개의 데이터를 한 번에 저장할 수 있는 데이터 구조입니다.
# - 대괄호 `[]`를 사용하여 정의하며, 요소들은 쉼표 `,` 로 구분됩니다.
# - 리스트의 각 요소는 **0부터 시작하는 인덱스(index)**를 가집니다.
# - 리스트에는 **문자, 숫자, 논리형 값뿐만 아니라 리스트 자체도 저장할 수 있습니다.** (리스트 안에 리스트 가능)

# - 여러 개의 값을 하나의 변수에 저장할 수 있는 데이터 구조이다.
# - 리스트의 요소들은 **쉼표(`,`)**로 구분하며, 대괄호(`[]`)를 사용하여 정의한다.
# - 리스트에는 **문자, 숫자뿐만 아니라 리스트 자체도 저장할 수 있다.** (리스트 안에 리스트 가능)

# ✅ 리스트의 기본 구조
# - 리스트는 빈 상태일 수도 있고, 여러 개의 요소를 포함할 수도 있다.
# - 요소들은 **0부터 시작하는 인덱스(index)**를 가진다.

# ✅ 리스트 예제
my_list1 = []           # 빈 리스트 (값이 없음)
my_list2 = [1, 2, 3]    # 숫자 리스트
my_list3 = ['a', 'b']   # 문자열 리스트
my_list4 = [[1, 2], [3, 4]]  # 리스트 안에 리스트 포함 가능 (이중 리스트)

# ✅ 빈 리스트(Empty List)의 필요성
# - 빈 리스트는 데이터를 나중에 추가할 공간을 마련하는 역할을 한다.
# - 예를 들어, **라면을 끓이려면 냄비가 필요하듯이, 리스트에 값을 추가하려면 먼저 리스트를 생성해야 한다.**

# ❌ 잘못된 예제: 리스트 없이 데이터를 추가하려 하면 오류 발생
# my_list.append(1)  # 리스트가 선언되지 않아 오류 발생

# ✅ 올바른 예제: 빈 리스트를 먼저 선언한 후 데이터를 추가할 수 있음
my_list = []  # 빈 리스트 생성 (마치 '빈 냄비'처럼)

# ✅ 리스트에서 값을 추가하는 방법: append() 메소드
# - `append()` 메소드는 리스트에 새로운 요소를 **맨 뒤에 추가**하는 기능을 한다.
# - 리스트에서만 사용할 수 있는 메소드이다.
# - 추가할 값은 `append(값)`의 괄호 안에 입력한다.

# ✅ append() 메소드 기본 구조
# 리스트이름.append(추가할값)

# ✅ 메소드(Method)란?
# - 특정한 자료형에서만 사용 가능한 함수이다.
# - 예를 들어, `append()`는 리스트에서만 사용할 수 있는 메소드이다.
# - 함수와 마찬가지로 입력이 들어가면 출력을 반환하는 역할을 한다.

# ✅ 예제: 빈 리스트 생성 후 값 추가
my_list = []  # 빈 리스트 생성

# 리스트에 다양한 자료형 추가
my_list.append(123)   # 정수 추가
my_list.append('abc') # 문자열 추가
my_list.append(True)  # 논리형 (Boolean) 추가

# ✅ 리스트에 추가된 값 확인
# - 처음에는 빈 리스트였지만 `append()`를 사용해 하나씩 요소가 추가됨.
# - 요소들은 추가된 순서대로 리스트의 맨 뒤에 붙는다.

# ✅ 리스트에서 요소 삭제하기 (del 키워드)
# - `del` 키워드를 사용하면 특정 인덱스의 요소를 삭제할 수 있습니다.
# - 삭제 후에는 리스트 내 요소들이 앞으로 이동하여 인덱스가 재배치됩니다.
# - `del 리스트이름`을 사용하면 리스트 자체를 삭제할 수도 있습니다.

# - `del` 키워드는 **리스트의 특정 요소를 삭제**할 때 사용된다.
# - 리스트에서 요소를 삭제하면 **뒤에 있는 요소들이 앞으로 당겨진다.**
# - `del 리스트이름[인덱스]` 형태로 사용한다.

# ✅ 예제: 특정 인덱스의 요소 삭제
my_list = [123, 'abc', True]  # 초기 리스트

del my_list[0]  # 0번 인덱스(123) 삭제
print(my_list)  # 출력: ['abc', True]

del my_list[1]  # 1번 인덱스(True) 삭제
print(my_list)  # 출력: ['abc']

# ✅ 리스트 슬라이싱을 이용한 부분 삭제
# - `del 리스트이름[시작인덱스:끝인덱스]` 형태로 사용한다.
# - 슬라이싱을 이용하면 여러 개의 요소를 한 번에 삭제할 수 있다.

my_list = ['a', 'b', 'c', 'd', 'e']  # 새로운 리스트 생성
del my_list[1:3]  # 1번 인덱스부터 2번 인덱스까지 삭제 ('b', 'c' 제거)
print(my_list)  # 출력: ['a', 'd', 'e']

# ✅ del 키워드로 리스트 전체 삭제
# - `del 리스트이름`을 사용하면 리스트 자체를 삭제할 수 있다.
del my_list  # 리스트 자체 삭제 (더 이상 사용 불가)


# ✅ 리스트에서 요소를 가져오기 (인덱싱)
# - 리스트에서 특정 위치의 값을 가져오려면 `리스트이름[인덱스]` 형식으로 접근합니다.
# - 리스트의 첫 번째 요소는 `0번` 인덱스부터 시작합니다.
# - 리스트의 마지막 요소는 `-1번` 인덱스로 접근할 수 있습니다. (음수 인덱스 지원)

# - 리스트의 각 요소에는 **0부터 시작하는 인덱스(index)**가 부여된다.
# - 리스트의 특정 요소를 가져오려면 `리스트이름[인덱스]`를 사용한다.
# - **음수 인덱스**를 사용하면 리스트의 끝에서부터 요소를 가져올 수 있다.

# ✅ 예제: 리스트 요소 접근 (인덱싱)
my_list = [123, 'abc', True]  # 리스트 선언

print(my_list[0])  # 0번 인덱스: 123 출력
print(my_list[1])  # 1번 인덱스: 'abc' 출력
print(my_list[-1])  # -1번 인덱스: True 출력 (마지막 요소)

# ✅ 리스트 슬라이싱(Slicing)
# - 리스트의 특정 범위를 선택하여 새로운 리스트를 만드는 기능이다.
# - **콜론(`:`)을 사용하여 시작 인덱스와 끝 인덱스를 지정한다.**
# - `리스트[시작인덱스:끝인덱스]` → 시작 인덱스부터 **끝 인덱스 전까지** 가져온다.
# - 슬라이싱을 사용해도 원본 리스트는 변경되지 않음.

# ✅ 예제: 리스트 슬라이싱
my_list = ['a', 'b', 'c']

# 1️⃣ 특정 범위 슬라이싱
print(my_list[:1])  # ['a'] (처음부터 1번 인덱스 전까지)
print(my_list[1:3])  # ['b', 'c'] (1번부터 3번 전까지)
print(my_list[2:])  # ['c'] (2번부터 끝까지)

# ✅ 리스트 슬라이싱 특징
# - 시작 인덱스를 생략하면 처음부터 선택됨 (예: `[:2]` → 0번부터 2번 전까지)
# - 끝 인덱스를 생략하면 마지막까지 선택됨 (예: `[1:]` → 1번부터 끝까지)
# - 슬라이싱 결과는 **새로운 리스트**이며, 원본 리스트는 변경되지 않음.

# ✅ 예제: 다양한 리스트 슬라이싱
numbers = [10, 20, 30, 40, 50]

print(numbers[1:4])  # [20, 30, 40] (1번부터 4번 전까지)
print(numbers[:3])   # [10, 20, 30] (처음부터 3번 전까지)
print(numbers[2:])   # [30, 40, 50] (2번부터 끝까지)
print(numbers[:])    # [10, 20, 30, 40, 50] (전체 리스트 복사)
print(numbers[-3:])  # [30, 40, 50] (뒤에서 3번째부터 끝까지)

# ✅ 슬라이싱을 활용한 리스트 복사
# - `[:]`을 사용하면 리스트 전체를 복사할 수 있음.
new_list = numbers[:]
print(new_list)  # [10, 20, 30, 40, 50] (원본과 동일한 새 리스트 생성)

# ✅ 리스트에서 값 변경하기
# - 리스트의 특정 요소를 변경하려면 `리스트이름[인덱스] = 새로운값` 형태로 사용한다.
# - 리스트는 **값을 수정할 수 있는(mutable) 자료형**이므로, 특정 요소를 직접 변경할 수 있다.

# ✅ 예제: 리스트 요소 값 변경
my_list = [123, 'abc', True]  # 초기 리스트 선언

my_list[0] = 3.14  # 0번 인덱스 값을 3.14로 변경
my_list[1] = 'ABC'  # 1번 인덱스 값을 'ABC'로 변경
my_list[-1] = False  # 마지막 요소(-1번 인덱스)를 False로 변경

# ✅ 변경된 리스트 확인
print(my_list)  # 출력: [3.14, 'ABC', False]


# ✅ 예제: 리스트에서 요소 가져오기
# - 리스트에서 특정 요소를 가져와 변수를 할당하고 사용할 수 있다.
# - 리스트의 **슬라이싱(slicing)**을 이용하면 여러 개의 요소를 한 번에 가져올 수도 있다.

my_list = ['딸기맛', '레몬맛', '수박맛', '우유맛', '콜라맛', '포도맛']

first_candy = my_list[0]  # 0번 인덱스의 값을 변수에 저장
print('채셔고양이에게는', first_candy, '사탕을 줘요.')  # 출력: 채셔고양이에게는 딸기맛 사탕을 줘요.

second_candy = my_list[1]  # 1번 인덱스 값 저장
print('오리에게는', second_candy, '사탕을 줘요.')  # 출력: 오리에게는 레몬맛 사탕을 줘요.

some_candies = my_list[2:5]  # 2번 ~ 4번 인덱스의 값 슬라이싱하여 저장
print('도도새에게는', some_candies, '사탕을 줘요.')  # 출력: 도도새에게는 ['수박맛', '우유맛', '콜라맛'] 사탕을 줘요.


# ✅ 리스트에 요소 추가 및 삭제하기
# - `append(값)`: 리스트 **끝에 요소를 추가**하는 메소드
# - `del 리스트이름[인덱스]`: **특정 인덱스의 요소를 삭제**하는 키워드

# ✅ 예제: 리스트 요소 추가 및 삭제
my_list = ['레몬맛', '박하맛']
print(my_list)  # 출력: ['레몬맛', '박하맛']

my_list.append('콜라맛')  # '콜라맛' 추가
print(my_list)  # 출력: ['레몬맛', '박하맛', '콜라맛']

my_list.append('포도맛')  # '포도맛' 추가
print(my_list)  # 출력: ['레몬맛', '박하맛', '콜라맛', '포도맛']

del my_list[1]  # 1번 인덱스('박하맛') 삭제
print(my_list)  # 출력: ['레몬맛', '콜라맛', '포도맛']

# ✅ 리스트 정렬하기 (sort 메소드)
# - `sort()` 메소드는 리스트의 요소를 **오름차순(작은 값 → 큰 값)으로 정렬**한다.
# - `sort()`를 사용하면 리스트 자체가 변경되며, 반환값은 `None`이다.
# - 문자열 리스트의 경우, **가나다순(알파벳 순서)**으로 정렬됨.
# - 원본 리스트를 유지하면서 정렬된 새 리스트를 얻고 싶다면 `sorted()` 사용.

# 숫자 정렬 예제
my_list = [3, 2, 4, 1]   # 숫자 리스트
my_list.sort()           # 오름차순 정렬 (1,2,3,4로 변경됨)
print(my_list)           # 출력: [1, 2, 3, 4]

# 문자열 정렬 예제
my_list = ['c', 'b', 'd', 'a']  # 문자열 리스트
my_list.sort()                   # 알파벳 순서로 정렬 (a,b,c,d로 변경됨)
print(my_list)                   # 출력: ['a', 'b', 'c', 'd']

# ✅ 다양한 정렬 방법 (sort() 옵션 활용)
# 1. `reverse=True` → 내림차순 정렬
# 2. `key=len` → 문자열 길이 기준 정렬
# 3. `key=len, reverse=True` → 문자열 길이 기준 내림차순 정렬

my_list = ['채셔고양이', '오리', '도도새']
my_list.sort()  # 가나다 순 정렬
print(my_list)  # 출력: ['도도새', '오리', '채셔고양이']

my_list.sort(reverse=True)  # 내림차순 정렬
print(my_list)  # 출력: ['채셔고양이', '오리', '도도새']

my_list.sort(key=len)  # 문자열 길이 기준 정렬 (짧은 순서)
print(my_list)  # 출력: ['오리', '도도새', '채셔고양이']

my_list.sort(key=len, reverse=True)  # 문자열 길이 기준 내림차순 정렬
print(my_list)  # 출력: ['채셔고양이', '도도새', '오리']

# ✅ 정렬 시 주의할 점
# - `sort()`는 원본 리스트 자체를 변경함.
# - 원본 리스트를 유지하면서 정렬된 새 리스트를 얻고 싶다면 `sorted()` 사용.

original = [3, 1, 4, 2]
sorted_list = sorted(original)   # 원본을 유지하고 새 리스트 생성
print(sorted_list)               # 출력: [1, 2, 3, 4]
print(original)                  # 출력: [3, 1, 4, 2] (원본 유지됨)

# ✅ 리스트에서 특정 요소 개수 세기 (count 메소드)
# - `count(값)` 메소드를 사용하면 리스트 내에서 해당 값이 몇 개 존재하는지 확인할 수 있습니다.
# - 특히, 데이터가 많을 때 특정 값의 개수를 빠르게 세는 데 유용합니다.

# - `count(값)`을 사용하면 리스트에서 해당 **값이 몇 개 포함되어 있는지** 확인할 수 있다.
# - 리스트에 같은 요소가 여러 개 있는 경우, **총 개수를 반환**한다.

# ✅ 예제: 특정 요소 개수 세기
my_list = ['a', 'c', 'a', 'b']  # 리스트 선언

print(my_list.count('a'))  # 'a'의 개수 출력 (결과: 2)
print(my_list.count('b'))  # 'b'의 개수 출력 (결과: 1)
print(my_list.count('c'))  # 'c'의 개수 출력 (결과: 1)

# ✅ count() 메소드의 활용
# - 리스트의 요소 개수를 직접 세지 않고, **자동으로 개수를 계산할 때 유용**하다.
# - 리스트 요소 개수가 많아질수록 `count()`를 활용하면 **더 빠르고 정확하게 개수를 셀 수 있음**.

# 예제: 대량 데이터에서 특정 값 개수 세기
big_list = ['apple'] * 1000 + ['banana'] * 500 + ['cherry'] * 250
print(big_list.count('apple'))   # 'apple' 개수 출력 (결과: 1000)
print(big_list.count('banana'))  # 'banana' 개수 출력 (결과: 500)
print(big_list.count('cherry'))  # 'cherry' 개수 출력 (결과: 250)

# ✅ count() 메소드 정리
# - 리스트에서 **특정 요소가 몇 개 있는지 확인**할 때 사용.
# - 직접 요소를 세는 것보다 빠르고 실수가 없음.
# - 요소 개수가 많을 때 특히 유용함!

# ✅ 리스트에서 특정 요소가 존재하는지 확인하기 (in, not in 키워드)
# - `in` 키워드를 사용하면 **특정 값이 리스트에 포함되어 있는지 여부**를 확인할 수 있다.
# - `not in` 키워드를 사용하면 **특정 값이 리스트에 포함되지 않았는지 여부**를 확인할 수 있다.
# - 결과는 **논리형(boolean) 값(True 또는 False)**으로 반환된다.

# ✅ 예제: 리스트 요소 포함 여부 확인
my_list = ['a', 'b', 'c', 'd']  # 리스트 선언

print('a' in my_list)  # 'a'가 my_list에 포함되어 있는지 확인 (결과: True)
print('f' not in my_list)  # 'f'가 my_list에 없는지 확인 (결과: True)

# ✅ in / not in 활용 예제
# - 특정 값이 리스트에 있는지 확인하고 조건문에서 활용할 수 있다.

if 'b' in my_list:
    print("'b'는 리스트에 포함되어 있습니다!")  # 출력됨

if 'z' not in my_list:
    print("'z'는 리스트에 포함되어 있지 않습니다!")  # 출력됨

# ✅ in / not in 정리
# - 리스트에 특정 요소가 존재하는지 확인할 때 유용함.
# - `in`은 포함 여부 확인 (`True` / `False` 반환).
# - `not in`은 포함되지 않음을 확인 (`True` / `False` 반환).
